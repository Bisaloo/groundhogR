# 2.0.5 Parse pkg_vrs into pkg and vrs
get.pkg <- function(x) substr(x, 1, regexpr("_", basename(x)) - 1)
get.vrs <- function(x) substr(x, regexpr("_", basename(x)) + 1, nchar(x))

#' Is pkg_vrs installed (within same R-minor version)?
#'
#' @inheritParams get.installed_path
is.pkg_vrs.installed <- function(pkg, vrs) {
  (get.installed_path(pkg, vrs) %in% get.pkg_search_paths(pkg, vrs))
}

#' Format Y-M-D as date
#'
#' @param x character string containing the date in the format "%Y-%m-%d"
#'
as.DateYMD <- function(x) as.Date(x, format = "%Y-%m-%d")

# 2.2  R Being used
# 2.2.1 R Date
get.rdate <- function() {
  date <- paste0(R.version$year, "-", R.version$month, "-", R.version$day)
  return(as.DateYMD(date))
}

# 2.2.2 R Version
get.rversion <- function() {
  r.version <- paste0(R.version$major, ".", R.version$minor)
  return(r.version)
}

# message1() are messages that are coloured if the terminal supports it and
# that have a special "groundhog-msg" class that makes it possible to disable
# them selectively using suppressMessages(     , class = "groundhog-msg")
message1 <- function(..., domain = NULL, appendLF = TRUE, quiet = getOption("quiet.groundhog", default = FALSE)) {
  if (quiet) {
    return(invisible())
  }
  if (.pkgenv[["supportsANSI"]]) {
    msg <- .makeMessage("\033[36m", ..., "\033[0m", domain = domain, appendLF = appendLF)
  } else {
    msg <- .makeMessage(..., domain = domain, appendLF = appendLF)
  }
  msg <- simpleMessage(msg)
  msg <- structure(msg, class = c("groundhog-msg", class(msg)))
  message(msg)
}

message2 <- function(..., domain = NULL, appendLF = TRUE, quiet = getOption("quiet.groundhog", default = FALSE)) {
  if (quiet) {
    return(invisible())
  }
  msg <- list(...)
  if (length(msg) == 0) {
    msg <- c("groundhog.library() says [using R-", get.rversion(), "]:")
  }

  if (.pkgenv[["supportsANSI"]]) {
    msg <- .makeMessage("\033[1;36m", msg, "\033[0m", domain = domain, appendLF = appendLF)
  } else {
    msg <- .makeMessage(msg, domain = domain, appendLF = appendLF)
  }
  msg <- simpleMessage(msg)
  msg <- structure(msg, class = c("groundhog-msg", class(msg)))
  message(msg)
}
# 2.8 Automatically name elements in list with name of the objects in the list
# https://stackoverflow.com/questions/16951080/can-lists-be-created-that-name-themselves-based-on-input-object-names
#' @importFrom stats setNames
namedList <- function(...) {
  L <- list(...)
  snm <- sapply(substitute(list(...)), deparse)[-1]
  if (is.null(nm <- names(L))) {
    nm <- snm
  }
  if (any(nonames <- nm == "")) {
    nm[nonames] <- snm[nonames]
  }
  setNames(L, nm)
}

# 2.10 Quit menu
quit.menu <- function(date, quiet = getOption("quiet.groundhog", default = FALSE)) {
  if (quiet) {
    return(invisible())
  }
  message1(
    "Type 'Q', 'quit' or 'stop' to stop the script.\nAnything else to continue"
  )
  x <- readline("")
  if (tolower(x) %in% c("q", "quit", "stop")) {
    message2()
    message1("You typed ", x, " so script stops...")
    msg.R.switch(date)
    stop("---")
  } # End if quit

  message1("You typed '", x, "' the script continues...")
} # End quit.menu
